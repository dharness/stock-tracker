// Service to load stock data from static JSON file (generated by GitHub Actions)
// This is an alternate version that reads from public/data/stocks.json instead of making API calls
// Use this for production when the JSON file is available

// Use process.env.PUBLIC_URL to handle GitHub Pages subdirectory correctly
// process.env.PUBLIC_URL is set by Create React App based on the "homepage" field in package.json
const STATIC_DATA_URL = `${process.env.PUBLIC_URL || ''}/data/stocks.json`;

export interface PriceData {
  date: string;
  price: number;
}

interface StaticStockData {
  lastUpdated: string;
  stocks: {
    [key: string]: PriceData[]; // Key format: "SYMBOL" (contains all historical data)
  };
}

// Cache the loaded data to avoid re-fetching
let cachedData: StaticStockData | null = null;
let cacheLoadPromise: Promise<StaticStockData | null> | null = null;

/**
 * Loads the static JSON file (cached after first load)
 * @returns StaticStockData or null if file doesn't exist
 */
const loadStaticData = async (): Promise<StaticStockData | null> => {
  // Return cached data if available
  if (cachedData) {
    return cachedData;
  }

  // If already loading, wait for that promise
  if (cacheLoadPromise) {
    return await cacheLoadPromise;
  }

  // Start loading
  cacheLoadPromise = (async () => {
    try {
      const response = await fetch(STATIC_DATA_URL);
      if (!response.ok) {
        console.warn("Static data file not found, returning null");
        return null;
      }

      const data: StaticStockData = await response.json();
      cachedData = data;
      console.log(
        `Loaded static stock data (last updated: ${data.lastUpdated})`
      );
      return data;
    } catch (error) {
      console.error("Error loading static stock data:", error);
      return null;
    } finally {
      cacheLoadPromise = null; // Clear the loading promise
    }
  })();

  return await cacheLoadPromise;
};

/**
 * Fetches historical stock data from static JSON file, filtered by year
 * @param symbol Stock ticker symbol (e.g., "AAPL")
 * @param year Year to filter data for (default: 2025)
 * @param retries Not used, kept for interface compatibility
 * @returns Array of price data points with date and price for the specified year
 */
export const fetchStockData = async (
  symbol: string,
  year: number = 2025,
  retries: number = 3
): Promise<PriceData[]> => {
  const staticData = await loadStaticData();
  if (!staticData) {
    console.warn(`Static data not available for ${symbol}`);
    return [];
  }

  // Try new format first (symbol key), then fall back to old format (symbol_year key)
  let allData = staticData.stocks[symbol] || [];
  
  // If not found, try old format with year suffix
  if (allData.length === 0) {
    const oldKey = `${symbol}_${year}`;
    allData = staticData.stocks[oldKey] || [];
  }
  
  // If still not found, try to find any year for this symbol (for migration)
  if (allData.length === 0) {
    const symbolKeys = Object.keys(staticData.stocks).filter(key => key.startsWith(`${symbol}_`));
    if (symbolKeys.length > 0) {
      // Merge all years of data for this symbol
      allData = [];
      symbolKeys.forEach(key => {
        const yearData = staticData.stocks[key] || [];
        allData = allData.concat(yearData);
      });
      // Sort by date and remove duplicates
      allData.sort((a, b) => a.date.localeCompare(b.date));
    }
  }

  if (!allData || allData.length === 0) {
    console.warn(`No data found for ${symbol} in static file`);
    return [];
  }

  // Filter by year
  const yearStart = `${year}-01-01`;
  const yearEnd = `${year}-12-31`;
  const filteredData = allData.filter(
    (point) => point.date >= yearStart && point.date <= yearEnd
  );

  if (filteredData.length === 0) {
    console.warn(`No data found for ${symbol} in year ${year}`);
    return [];
  }

  console.log(
    `Loaded ${symbol} (${year}) from static data: ${filteredData.length} data points (filtered from ${allData.length} total)`
  );
  return filteredData;
};

/**
 * Fetches stock data for multiple symbols from static JSON file
 * Returns all available data (not filtered by year)
 * @param symbols Array of stock ticker symbols
 * @param delayMs Not used, kept for interface compatibility
 * @returns Map of symbol to price data array (all historical data)
 */
export const fetchMultipleStockData = async (
  symbols: string[],
  delayMs: number = 12000
): Promise<Map<string, PriceData[]>> => {
  const staticData = await loadStaticData();
  if (!staticData) {
    console.warn("Static data not available");
    return new Map();
  }

  const dataMap = new Map<string, PriceData[]>();

  symbols.forEach((symbol) => {
    // Try new format first (symbol key), then fall back to old format
    let data = staticData.stocks[symbol] || [];
    
    // If not found, try to find any year for this symbol (for migration)
    if (data.length === 0) {
      const symbolKeys = Object.keys(staticData.stocks).filter(key => key.startsWith(`${symbol}_`));
      if (symbolKeys.length > 0) {
        // Merge all years of data for this symbol
        data = [];
        symbolKeys.forEach(key => {
          const yearData = staticData.stocks[key] || [];
          data = data.concat(yearData);
        });
        // Sort by date and remove duplicates
        data.sort((a, b) => a.date.localeCompare(b.date));
      }
    }
    
    if (data && data.length > 0) {
      dataMap.set(symbol, data);
    }
  });

  return dataMap;
};

/**
 * Fetches stock data progressively from static JSON file
 * Calls onProgress for each stock as it's loaded, filtered by year
 * @param symbols Array of stock ticker symbols
 * @param onProgress Callback called when each stock is loaded (symbol, data, currentIndex, total)
 * @param year Year to filter data for (default: 2025)
 * @param initialDelayMs Not used, kept for interface compatibility
 * @param rateLimitedDelayMs Not used, kept for interface compatibility
 */
export const fetchMultipleStockDataProgressive = async (
  symbols: string[],
  onProgress: (
    symbol: string,
    data: PriceData[],
    currentIndex: number,
    total: number
  ) => void,
  year: number = 2025,
  initialDelayMs: number = 2000,
  rateLimitedDelayMs: number = 12000
): Promise<void> => {
  const staticData = await loadStaticData();
  if (!staticData) {
    console.warn("Static data not available");
    // Call onProgress with empty data for all symbols
    symbols.forEach((symbol, index) => {
      onProgress(symbol, [], index + 1, symbols.length);
    });
    return;
  }

  // Filter by year
  const yearStart = `${year}-01-01`;
  const yearEnd = `${year}-12-31`;

  let completed = 0;
  symbols.forEach((symbol) => {
    // Try new format first (symbol key), then fall back to old format (symbol_year key)
    let allData = staticData.stocks[symbol] || [];
    
    // If not found, try old format with year suffix
    if (allData.length === 0) {
      const oldKey = `${symbol}_${year}`;
      allData = staticData.stocks[oldKey] || [];
    }
    
    // If still not found, try to find any year for this symbol (for migration)
    if (allData.length === 0) {
      const symbolKeys = Object.keys(staticData.stocks).filter(key => key.startsWith(`${symbol}_`));
      if (symbolKeys.length > 0) {
        // Merge all years of data for this symbol
        allData = [];
        symbolKeys.forEach(key => {
          const yearData = staticData.stocks[key] || [];
          allData = allData.concat(yearData);
        });
        // Sort by date and remove duplicates
        allData.sort((a, b) => a.date.localeCompare(b.date));
      }
    }
    
    // Filter data for the specified year
    const filteredData = allData.filter(
      (point) => point.date >= yearStart && point.date <= yearEnd
    );

    if (filteredData.length > 0) {
      completed++;
      console.log(
        `Loaded ${symbol} (${year}) from static data: ${filteredData.length} data points (filtered from ${allData.length} total)`
      );
    } else {
      console.warn(`No data found for ${symbol} (${year}) in static file`);
    }

    onProgress(symbol, filteredData, completed, symbols.length);
  });
};
